import numpy as np

# Гиперболический тангенс, функция вычисления гиперболического тангенса
def f(x):
    return 2 / (1 + np.exp(-x)) - 1

# Функция вычисления производной
def df(x):
    return 0.5 * (1 + x) * (1 - x)

# Инициализация рандомных весов для первого и второго слоя
W1 = np.array([[-0.2, 0.3, -0.4], [0.1, -0.3, -0.4]])
W2 = np.array([0.2, 0.3])

# Пропускаем вектор наблюдения через нейронную сеть 
def go_forward(inp):
    sum = np.dot(W1, inp)
    out = np.array([f(x) for x in sum])  # для каждого нейрона запоминаем выходные значения скрытого слоя (out)

    sum = np.dot(W2, out)
    y = f(sum)  # выходное значение для всей нейронной сети, для последнего нейрона
    return (y, out)

# Обучение сети
def train(epoch):
    global W2, W1
    lmd = 0.005  # шаг обучения
    N = 100000   # число итераций при обучении
    count = len(epoch)
    for k in range(N):
        x = epoch[np.random.randint(0, count)]  # случайный выбор входного сигнала из обучающей выборки
        y, out = go_forward(x[0:3])            # прямой проход по нейросети и запоминание выходных значений на каждом нейроне
        e = y - x[-1]                          # вычисление ошибки на последнем нейроне
        delta = e * df(y)                      # локальный градиент
        W2[0] = W2[0] - lmd * delta * out[0]   # корректировка веса первой связи
        W2[1] = W2[1] - lmd * delta * out[1]   # корректировка веса второй связи

        delta2 = W2 * delta * df(out)          # вектор из двух величин локальных градиентов

        # корректировка связей первого слоя
        W1[0, :] = W1[0, :] - np.array(x[0:3]) * delta2[0] * lmd
        W1[1, :] = W1[1, :] - np.array(x[0:3]) * delta2[1] * lmd

        # Каждые 1000 итераций выводим среднюю ошибку по выборке
        if k % 1000 == 0:
            total_error = 0
            for sample in epoch:
                predicted, _ = go_forward(sample[0:3])
                total_error += (predicted - sample[-1])**2
            avg_error = total_error / count
            print(f"Итерация {k}, средняя ошибка: {avg_error:.6f}")

# Обучающая выборка
epoch = [(-1, -1, -1, 1),
         (-1, -1, 1, 1),
         (-1, 1, -1, -1),
         (-1, 1, 1, -1),
         (1, -1, -1, 1),
         (1, -1, 1, 1),
         (1, 1, -1, -1),
         (1, 1, 1, -1)]

# Запуск обучения сети
train(epoch)

# Проверка обученной сети
print("\nПроверка результатов на обучающей выборке:")
for x in epoch:
    y, _ = go_forward(x[0:3])
    print(f"Вход: {x[0:3]} => Выход сети: {y:.6f}, Ожидание: {x[-1]}")

# Пользовательский ввод для проверки
print("\nВведите три числа через пробел (например, 1 -1 1):")
user_input = list(map(int, input().split()))

if len(user_input) == 3:
    y, _ = go_forward(user_input)
    result = 1 if y >= 0 else -1
    print(f"Результат для ввода {user_input}: {result}")
else:
    print("Ошибка: необходимо ввести ровно три числа.")
